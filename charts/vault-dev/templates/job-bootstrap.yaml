{{- if and .Values.enabled .Values.bootstrap.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Values.service.name }}-bootstrap
  annotations:
    checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
spec:
  template:
    spec:
      restartPolicy: OnFailure
      serviceAccountName: {{ printf "%s-bootstrap" .Values.service.name }}
      volumes:
        - name: bootstrap-secret
          secret:
            secretName: {{ .Values.bootstrap.secretName | default (printf "%s-bootstrap" .Values.service.name) }}
            optional: true
      containers:
        - name: vault-bootstrap
          image: {{ .Values.image.repository }}:{{ .Values.image.tag }}
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          env:
            - name: VAULT_ADDR
              value: http://{{ .Values.service.name }}:{{ .Values.service.port }}
            - name: KUBERNETES_HOST
              value: https://kubernetes.default.svc
          command: ["/bin/sh","-ceu","x"]
          args:
            - |
              set -euo pipefail

              log() { printf '[bootstrap] %s\n' "$*"; }

              SA_TOKEN_FILE="/var/run/secrets/kubernetes.io/serviceaccount/token"
              CA_CERT="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
              NAMESPACE="{{ .Release.Namespace }}"
              SECRET_PATH="/bootstrap-secret"
              SECRET_NAME='{{ .Values.bootstrap.secretName | default (printf "%s-bootstrap" .Values.service.name) }}'

              ROOT_TOKEN=""
              UNSEAL_KEY=""

              if [ -f "$SECRET_PATH/root_token" ]; then
                ROOT_TOKEN=$(cat "$SECRET_PATH/root_token")
              fi
              if [ -f "$SECRET_PATH/unseal_key" ]; then
                UNSEAL_KEY=$(cat "$SECRET_PATH/unseal_key")
              fi

              wait_for_vault() {
                log "waiting for Vault HTTP endpointâ€¦"
                for i in $(seq 1 120); do
                  if wget -qO- "${VAULT_ADDR}/v1/sys/health" >/dev/null 2>&1; then
                    return 0
                  fi
                  sleep 2
                done
                log "ERROR: Vault HTTP endpoint not reachable"
                return 1
              }

              json_get_bool() {
                key="$1"
                data="$2"
                printf '%s' "$data" | tr -d '\n' | sed -n "s/.*\"${key}\":\s*\(true\|false\).*/\1/p"
              }

              parse_init_json() {
                init_json="$1"
                flat=$(printf '%s' "$init_json" | tr -d '\n')
                ROOT_TOKEN=$(printf '%s' "$flat" | sed -n 's/.*"root_token":"\([^"]*\)".*/\1/p')
                UNSEAL_KEY=$(printf '%s' "$flat" | sed -n 's/.*"unseal_keys_b64":\["\([^"]*\)".*/\1/p')
              }

              ensure_secret() {
                if [ -z "$ROOT_TOKEN" ] || [ -z "$UNSEAL_KEY" ]; then
                  log "WARNING: skipping secret creation (missing tokens)"
                  return 0
                fi
                AUTH_HEADER="Authorization: Bearer $(cat ${SA_TOKEN_FILE})"
                cat > /tmp/secret.json <<JSON
                {
                  "apiVersion": "v1",
                  "kind": "Secret",
                  "metadata": {
                    "name": "${SECRET_NAME}",
                    "namespace": "${NAMESPACE}"
                  },
                  "type": "Opaque",
                  "stringData": {
                    "root_token": "${ROOT_TOKEN}",
                    "unseal_key": "${UNSEAL_KEY}"
                  }
                }
                JSON
                log "storing credentials in Secret ${SECRET_NAME}"
                wget --quiet --output-document=/dev/null --ca-certificate="$CA_CERT" --header "$AUTH_HEADER" --method=DELETE "${KUBERNETES_HOST}/api/v1/namespaces/${NAMESPACE}/secrets/${SECRET_NAME}" || true
                wget --quiet --output-document=/dev/null --ca-certificate="$CA_CERT" --header "$AUTH_HEADER" --header "Content-Type: application/json" --post-file=/tmp/secret.json "${KUBERNETES_HOST}/api/v1/namespaces/${NAMESPACE}/secrets"
              }

              wait_for_vault

              status_json=$(vault status -format=json 2>/dev/null || true)
              status_flat=$(printf '%s' "$status_json" | tr -d '\n')
              initialized=$(json_get_bool initialized "$status_flat")
              sealed=$(json_get_bool sealed "$status_flat")

              if [ "$initialized" != "true" ]; then
                log "initializing Vault (single-share dev setup)"
                init_out=$(vault operator init -key-shares=1 -key-threshold=1 -format=json)
                parse_init_json "$init_out"
                if [ -z "$ROOT_TOKEN" ] || [ -z "$UNSEAL_KEY" ]; then
                  log "ERROR: failed to parse init response"
                  exit 1
                fi
                log "unsealing newly initialized Vault"
                vault operator unseal "$UNSEAL_KEY"
                ensure_secret
              else
                if [ "$sealed" = "true" ]; then
                  if [ -z "$UNSEAL_KEY" ]; then
                    log "ERROR: Vault sealed and no unseal key provided (mount Secret '{{ .Values.bootstrap.secretName }}')"
                    exit 1
                  fi
                  log "unsealing existing Vault"
                  vault operator unseal "$UNSEAL_KEY"
                fi
                if [ -z "$ROOT_TOKEN" ]; then
                  log "WARNING: root token not available; policy/bootstrap steps may be skipped"
                fi
              fi

              if [ -n "$ROOT_TOKEN" ]; then
                export VAULT_TOKEN="$ROOT_TOKEN"

                log "ensuring KV v2 mount 'gitops' exists"
                if ! vault secrets list -format=json 2>/dev/null | tr -d '\n' | grep -q '"gitops/"'; then
                  vault secrets enable -path=gitops -version=2 kv >/dev/null
                fi

                log "configuring Kubernetes auth mount"
                vault auth enable -path=kubernetes kubernetes >/dev/null 2>&1 || true
                vault write auth/kubernetes/config \
                  token_reviewer_jwt="$(cat ${SA_TOKEN_FILE})" \
                  kubernetes_host="${KUBERNETES_HOST}" \
                  kubernetes_ca_cert=@${CA_CERT} >/dev/null

                log "writing dev policies"
                cat > /tmp/app.hcl <<'HCL'
                path "gitops/data/*" {
                  capabilities = ["create","read","update","list"]
                }
                path "gitops/metadata/*" {
                  capabilities = ["read","list"]
                }
                HCL
                vault policy write {{ .Values.bootstrap.appPolicyName }} /tmp/app.hcl >/dev/null
                vault write auth/kubernetes/role/{{ .Values.bootstrap.appRoleName }} \
                  bound_service_account_names="{{ join "," .Values.bootstrap.appServiceAccounts }}" \
                  bound_service_account_namespaces="{{ join "," .Values.bootstrap.appNamespaces }}" \
                  policies="{{ .Values.bootstrap.appPolicyName }}" \
                  ttl="1h" >/dev/null

                cat > /tmp/vco.hcl <<'HCL'
                path "auth/kubernetes/role/*" {
                  capabilities = ["create","read","update","delete","list"]
                }
                path "auth/kubernetes/config" {
                  capabilities = ["read","update"]
                }
                path "auth/kubernetes/*" {
                  capabilities = ["create","read","update","list"]
                }
                path "sys/policies/acl/*" {
                  capabilities = ["create","read","update","delete","list"]
                }
                path "auth/token/lookup-self" {
                  capabilities = ["read"]
                }
                path "auth/token/lookup" {
                  capabilities = ["read"]
                }
                path "auth/role/*" {
                  capabilities = ["read","list"]
                }
                path "sys/auth" {
                  capabilities = ["read","update"]
                }
                path "sys/auth/*" {
                  capabilities = ["create","read","update","delete","list"]
                }
                path "sys/policies/acl" {
                  capabilities = ["read","list"]
                }
                HCL
                vault policy write {{ .Values.bootstrap.vcoPolicyName }} /tmp/vco.hcl >/dev/null
                vault write auth/kubernetes/role/{{ .Values.bootstrap.vcoRoleName }} \
                  bound_service_account_names="{{ .Values.bootstrap.vcoServiceAccount }}" \
                  bound_service_account_namespaces="{{ .Values.bootstrap.vcoNamespace }}" \
                  policies="{{ .Values.bootstrap.vcoPolicyName }}" \
                  ttl="1h" >/dev/null
              else
                log "WARNING: skipping policy bootstrap (no root token)"
              fi

              ensure_secret
              log "bootstrap complete"
          volumeMounts:
            - name: bootstrap-secret
              mountPath: /bootstrap-secret
          securityContext:
            {{- toYaml .Values.securityContext | nindent 12 }}
{{- end }}
