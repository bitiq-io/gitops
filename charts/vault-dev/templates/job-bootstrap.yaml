{{- if and .Values.enabled .Values.bootstrap.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ .Values.service.name }}-bootstrap
  annotations:
    argocd.argoproj.io/sync-options: Replace=true
    checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
spec:
  template:
    spec:
      restartPolicy: OnFailure
      serviceAccountName: {{ printf "%s-bootstrap" .Values.service.name }}
      volumes:
        - name: bootstrap-secret
          secret:
            secretName: {{ .Values.bootstrap.secretName | default (printf "%s-bootstrap" .Values.service.name) }}
            optional: true
      containers:
        - name: vault-bootstrap
          image: {{ .Values.image.repository }}:{{ .Values.image.tag }}
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          env:
            - name: VAULT_ADDR
              value: http://{{ .Values.service.name }}:{{ .Values.service.port }}
            - name: KUBERNETES_HOST
              value: https://kubernetes.default.svc
          command: ["/bin/sh","-c"]
          args:
            - |
              set -euo pipefail

              log() { printf '[bootstrap] %s\n' "$*"; }

              SA_TOKEN_FILE="/var/run/secrets/kubernetes.io/serviceaccount/token"
              CA_CERT="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
              NAMESPACE="{{ .Release.Namespace }}"
              SECRET_PATH="/bootstrap-secret"
              SECRET_NAME='{{ .Values.bootstrap.secretName | default (printf "%s-bootstrap" .Values.service.name) }}'
              HEALTH_ENDPOINT="${VAULT_ADDR}/v1/sys/health?standbyok=true&sealedcode=204&uninitcode=204"

              ROOT_TOKEN=""
              UNSEAL_KEY=""

              if [ -f "$SECRET_PATH/root_token" ]; then
                ROOT_TOKEN=$(cat "$SECRET_PATH/root_token")
              fi
              if [ -f "$SECRET_PATH/unseal_key" ]; then
                UNSEAL_KEY=$(cat "$SECRET_PATH/unseal_key")
              fi

              CURL_URL="https://github.com/moparisthebest/static-curl/releases/latest/download/curl-amd64"

              ensure_curl() {
                if command -v curl >/dev/null 2>&1; then
                  return 0
                fi
                if [ ! -x /tmp/curl ]; then
                  log "downloading static curl"
                  if ! wget -q -O /tmp/curl "${CURL_URL}"; then
                    log "ERROR: failed to download curl from ${CURL_URL}"
                    return 1
                  fi
                  chmod +x /tmp/curl
                fi
                export PATH="/tmp:${PATH}"
                return 0
              }

              wait_for_vault() {
                ensure_curl
                log "waiting for Vault HTTP endpointâ€¦"
                for i in $(seq 1 120); do
                  if curl -fsS "${HEALTH_ENDPOINT}" >/dev/null 2>&1; then
                    return 0
                  fi
                  sleep 2
                done
                log "ERROR: Vault HTTP endpoint not reachable"
                return 1
              }

              json_get_bool() {
                key="$1"
                data="$2"
                printf '%s' "$data" | tr -d '\r\n' | sed -n "s/.*\"${key}\":\s*\(true\|false\).*/\1/p"
              }

              parse_init_output() {
                init_text="$1"
                clean=$(printf '%s' "$init_text" | tr -d '\r')
                ROOT_TOKEN=$(printf '%s\n' "$clean" | awk -F': ' '/Initial Root Token/ {print $2}')
                UNSEAL_KEY=$(printf '%s\n' "$clean" | awk -F': ' '/Unseal Key 1/ {print $2}')
              }

              ensure_secret() {
                ensure_curl
                if [ -z "$ROOT_TOKEN" ] || [ -z "$UNSEAL_KEY" ]; then
                  log "WARNING: skipping secret creation (missing tokens)"
                  return 0
                fi
                AUTH_HEADER="Authorization: Bearer $(cat ${SA_TOKEN_FILE})"
                printf '%s\n' \
                  '{' \
                  '  "apiVersion": "v1",' \
                  '  "kind": "Secret",' \
                  '  "metadata": {' \
                  "    \"name\": \"${SECRET_NAME}\"," \
                  "    \"namespace\": \"${NAMESPACE}\"" \
                  '  },' \
                  '  "type": "Opaque",' \
                  '  "stringData": {' \
                  "    \"root_token\": \"${ROOT_TOKEN}\"," \
                  "    \"unseal_key\": \"${UNSEAL_KEY}\"" \
                  '  }' \
                  '}' \
                  > /tmp/secret.json
                log "storing credentials in Secret ${SECRET_NAME}"
                curl -fsS --cacert "$CA_CERT" --header "$AUTH_HEADER" -X DELETE "${KUBERNETES_HOST}/api/v1/namespaces/${NAMESPACE}/secrets/${SECRET_NAME}" >/dev/null 2>&1 || true
                curl -fsS --cacert "$CA_CERT" --header "$AUTH_HEADER" --header "Content-Type: application/json" --data-binary @/tmp/secret.json "${KUBERNETES_HOST}/api/v1/namespaces/${NAMESPACE}/secrets" >/dev/null
              }

              wait_for_vault

              if [ -z "$ROOT_TOKEN" ] || [ -z "$UNSEAL_KEY" ]; then
                log "initializing Vault (single-share dev setup)"
                init_rc=0
                init_out=$(vault operator init -key-shares=1 -key-threshold=1 2>&1) || init_rc=$?
                if [ "$init_rc" -ne 0 ]; then
                  if printf '%s' "$init_out" | grep -q "Vault is already initialized"; then
                    log "ERROR: Vault already initialized but bootstrap Secret lacks tokens"
                    printf '%s\n' "$init_out"
                  else
                    log "ERROR: vault operator init failed:"
                    printf '%s\n' "$init_out"
                  fi
                  exit 1
                fi
                parse_init_output "$init_out"
                if [ -z "$ROOT_TOKEN" ] || [ -z "$UNSEAL_KEY" ]; then
                  log "ERROR: failed to parse init response"
                  exit 1
                fi
                log "unsealing newly initialized Vault"
                vault operator unseal "$UNSEAL_KEY"
                ensure_secret
              fi

              status_json=$(vault status -format=json 2>/dev/null || true)
              status_flat=$(printf '%s' "$status_json" | tr -d '\r\n')
              sealed=$(json_get_bool sealed "$status_flat")

              if [ "$sealed" = "true" ]; then
                if [ -z "$UNSEAL_KEY" ]; then
                  log "ERROR: Vault sealed and no unseal key provided (mount Secret '{{ .Values.bootstrap.secretName }}')"
                  exit 1
                fi
                log "unsealing existing Vault"
                vault operator unseal "$UNSEAL_KEY"
              fi

              if [ -z "$ROOT_TOKEN" ]; then
                log "WARNING: root token not available; policy/bootstrap steps may be skipped"
              fi

              if [ -n "$ROOT_TOKEN" ]; then
                export VAULT_TOKEN="$ROOT_TOKEN"

                log "ensuring KV v2 mount 'gitops' exists"
                if ! vault secrets list -format=json 2>/dev/null | tr -d '\r\n' | grep -q '"gitops/"'; then
                  vault secrets enable -path=gitops -version=2 kv >/dev/null
                fi

                log "configuring Kubernetes auth mount"
                vault auth enable -path=kubernetes kubernetes >/dev/null 2>&1 || true
                vault write auth/kubernetes/config \
                  token_reviewer_jwt="$(cat ${SA_TOKEN_FILE})" \
                  kubernetes_host="${KUBERNETES_HOST}" \
                  kubernetes_ca_cert=@${CA_CERT} >/dev/null

                log "writing dev policies"
                printf '%s\n' \
                  'path "gitops/data/*" {' \
                  '  capabilities = ["create","read","update","list"]' \
                  '}' \
                  'path "gitops/metadata/*" {' \
                  '  capabilities = ["read","list"]' \
                  '}' \
                  > /tmp/app.hcl
                vault policy write {{ .Values.bootstrap.appPolicyName }} /tmp/app.hcl >/dev/null
                vault write auth/kubernetes/role/{{ .Values.bootstrap.appRoleName }} \
                  bound_service_account_names="{{ join "," .Values.bootstrap.appServiceAccounts }}" \
                  bound_service_account_namespaces="{{ join "," .Values.bootstrap.appNamespaces }}" \
                  policies="{{ .Values.bootstrap.appPolicyName }}" \
                  ttl="1h" >/dev/null

                printf '%s\n' \
                  'path "auth/kubernetes/role/*" {' \
                  '  capabilities = ["create","read","update","delete","list"]' \
                  '}' \
                  'path "auth/kubernetes/config" {' \
                  '  capabilities = ["read","update"]' \
                  '}' \
                  'path "auth/kubernetes/*" {' \
                  '  capabilities = ["create","read","update","list"]' \
                  '}' \
                  'path "sys/policies/acl/*" {' \
                  '  capabilities = ["create","read","update","delete","list"]' \
                  '}' \
                  'path "auth/token/lookup-self" {' \
                  '  capabilities = ["read"]' \
                  '}' \
                  'path "auth/token/lookup" {' \
                  '  capabilities = ["read"]' \
                  '}' \
                  'path "auth/role/*" {' \
                  '  capabilities = ["read","list"]' \
                  '}' \
                  'path "sys/auth" {' \
                  '  capabilities = ["read","update"]' \
                  '}' \
                  'path "sys/auth/*" {' \
                  '  capabilities = ["create","read","update","delete","list"]' \
                  '}' \
                  'path "sys/policies/acl" {' \
                  '  capabilities = ["read","list"]' \
                  '}' \
                  > /tmp/vco.hcl
                vault policy write {{ .Values.bootstrap.vcoPolicyName }} /tmp/vco.hcl >/dev/null
                vault write auth/kubernetes/role/{{ .Values.bootstrap.vcoRoleName }} \
                  bound_service_account_names="{{ .Values.bootstrap.vcoServiceAccount }}" \
                  bound_service_account_namespaces="{{ .Values.bootstrap.vcoNamespace }}" \
                  policies="{{ .Values.bootstrap.vcoPolicyName }}" \
                  ttl="1h" >/dev/null
              else
                log "WARNING: skipping policy bootstrap (no root token)"
              fi

              ensure_secret
              log "bootstrap complete"
          volumeMounts:
            - name: bootstrap-secret
              mountPath: /bootstrap-secret
          securityContext:
            {{- toYaml .Values.securityContext | nindent 12 }}
{{- end }}
